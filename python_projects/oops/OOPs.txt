 ========= OOPS in python ==============

Python supports 
functional : The map(), filter() and reduce() functions bring a bit of functional programming to Python.
	All three of these are convenience functions that can be replaced with List Comprehensions or loops, but provide a more elegant and 		short-hand approach to some problems.

	# ==============  map()
	# Without using lambdas
	def starts_with_A(s):
    		return s[0] == "A"

	fruit = ["Apple", "Banana", "Pear", "Apricot", "Orange"]
	map_object = map(starts_with_A, fruit)

	print(list(map_object))  # [True, False, False, True, False]


	With lamda:
	
	fruit = ["Apple", "Banana", "Pear", "Apricot", "Orange"]
	map_object = map(lambda s: s[0] == "A", fruit)

	print(list(map_object))  # [True, False, False, True, False]

	

	# ============== filter()  # We can use lambda also similar to above
	

	def starts_with_A(s):
    		return s[0] == "A"

	fruit = ["Apple", "Banana", "Pear", "Apricot", "Orange"]
	filter_object = filter(starts_with_A, fruit)

	print(list(filter_object))  # ['Apple', 'Apricot']

	
	# ============== reduce()
	
	reduce() works differently than map() and filter(). It does not return a new list based on the function and iterable we've passed. 		Instead, it returns a single value.

	from functools import reduce

	def add(x, y):
    		return x + y

	list = [2, 4, 7, 3]
	print(reduce(add, list)) # 16  ie 2+4+6+3


Procedural
and OOP


class has
 attributes-> variables
 behaviour -> methods(function )


# ====================
Variable vs object

eg a= 8 . Here a is an object of class int. WE can check using print(type(a))

lets say we have class name as computer. and we do comp= computer()
THan comp is an object of class computer. 

So, conclusion from above is a variable assigned with built in class called as variable 
and variable assigned with class we create called as object.


THere is special memory called as heap memory to store object in particular address. FOr each object seperate address is allocated
we can get it by: print(id(comp))

Size of an object-> depends on number of variables we have

who allocated size to object, how much m/m to be given-> THis is done by constructor
comp= Computer() -> This is constructor, which callls __init__() method called internally

# ====  self ====

self is the object we are passing. Useful in accessing data in diff methods

eg

class Computer():

   def __init__(self, ram):
      self.ram= ram  # => THis is like comp1.ram= ram

   def config(self):
      print("i5, 16gb ram")

comp1= Computer("i5")  # => Its like Computer(comp1, "i5")
comp2= Computer("i7")

Computer.config(comp1) # comp1 is passed as an argument

comp1.config()  # Behind the scenec comp1 is passeed as an argument


Its a current instance of object. With it helps only, we are displaying config method according to the object.

#  =======  __init__() ===============

Its a special method. This is used to initialize variables. Will be called automatically.
For every instance created, it be called.

Ii is constructor.

# =========  Variables in oops =====================


Useful to store data
1. Instance variables -> THey are diff for diff object. They are defined inside init method
2. class/static variables -> They are commmon for all. They are define outside init but inside class

# == Namespace =================
two types:
1, class namespace -> Where class variable are declared 
2. instance namespace-> PLcae where instance bvariables are declared

# ===========  Method TYpes ====================
Methos is used to define behaviour

1. class method-> It will have cls and thus deal with class variables. WE have to use decorator @classmethod to work it. eg. 			class_name.class_method()
2. instance method -> IT will have self and thus deal with instance variables. 
	Its of 2 types:
	1. Accesors-> When you just want to get/access the instance variables called accesors. They are also called getters
	2. Mutators-> When we modify/set instance variables called mutators. They are also called setters
3. static method-> When we like to do something which is not depending on class variables/instance variables, we can use it. This is not 		related to class/ object. WE have to use @staticmethod decorator.


# ========== Inner class =================
Yes, we can do that.
eg
class Student:
  def __init__(self, name, roll):
	self.name= name
	self.roll= roll
	self.lap= self.laptop()  # Innecr class

  
  def show(self):
	print(self.name, self.roll)
	self.lap.show()  # Instance method of inner class

  class laptop:
	
	def __init__(self):
	   self.model= "hp"
	   self.cpu= "i5"
	   self.cost= 12000

	def show(self):
	   print(self.model, self.cpu, self.cost)

s1= Student("Inder", 12)
s1.show()

# ============ Inheritance ==================

Lets say we have 2 classes A and B. If B wanted to use all features of A. Than we can use inheritance.
Just have to use like: class B(A)

Example below is 
# single level inheritance. Where one child class inheriting 1 parent class.
parent(A)-> child(B) 
A is parent and B is child class

class A:
  def f1(self):
	print(f1)

class B(A):
  def f2(self):
	print(f2)

b1= B()
b1.      # It can access both f1 and f2

#  Multilevel inheritance
grandparent (A)-> parent(B)-> child(C)

C is having all features available from both A and class B. B is having all features from A also
class A:
  def f1(self):
	print(f1)

class B(A):
  def f2(self):
	print(f2)

class C(B):
  def f3(self):
	print(f3)

c1= C()
c1.  # It can access all f1, f2 and f3


# == Multiple Inheritance ====
parent (A)
	   -> child(C)
parent(B)   

C is inheriting features from one or more classes. Here B is having only f2 feature and A is having f1 feature

class A:
  def f1(self):
	print(f1)

class B:
  def f2(self):
	print(f2)

class C(A, B):
  def f3(self):
	print(f3)

c1= C()
c1.  # It can access all f1, f2 and f3




# ============  Constructor in inheritances ===============================

# ======== 1. HOw constructor behave in inheritance

class A:
  def __init__(self):
	print("init of A")
  def f1(self):
	print(f1)

class B(A):
  def __init__(self):
	print("init of B")
  def f2(self):
	print(f2)

b1= B() => It will inherit all features of class A. 
	It will first check, if init is present in class B(sub class) and display
	 if init not found in CLASS B, than check init in CLASS A(super class) and print init method.

ie. if you create object of subclass it will first try to find init of subclass,
If not found than only it will call init of super class


# ======== 2. HOw to use super() method ============

What if I like to call init of A also?
than use : super().__init__()  inside __init__() of class B
like:
class B(A):
  def __init__(self):
	super().__init__()
	print("init of B")

with super(). -> WE can access any method of super class. init as well other method of super class


Above is true for single level/ multi level inheritence. Ie where a child is inheriting a single parent.

But in case of multiple inheritence, where a child inherit multiple parents, 

like:
class A:
  def __init__(self):
	print("init of A")
  def f1(self):
	print(f1)

class B:
  def __init__(self):
	print("init of B")
  def f2(self):
	print(f2)

class C(A,B):
  def __init__(self):
	super().__init__()
	print("init of C")
  def f3(self):
	print(f3)

c1= C() => It will print init of A and init C only. And init of B will not be called. Here C(A, B) -> A is at first that is why.
It follows, first check for init in C than go to left CLASS Ie A to find init than comes right  CLASS ie B to find init.

above concept to get init method of parent class, fails. As, now sub class will have 2 super class.
 But super(). function used to call just one super class, and it gets confused.

# =============== 3. Method Resolution Order(MRO) ================================

To overcome above issue, MRO is used.

like:
class A:
  def __init__(self):
	print("init of A")
  def f1(self):
	print(f1 of class A)

class B:
  def __init__(self):
	print("init of B")
  def f1(self):
	print(f1 of class b)

class C(A,B):
  def __init__(self):
	super().__init__()
	print("init of C")
  def f2(self):
	print(f2)

c1= C() => # Constructor of A will be called and not constructor B as A in left. ==> init of A and init of C will be printed

c1.f1()   # f1 is common in A and B, f1 of A will be called as A is in left     => f1 of class A will be printed


# ===============  Polymorphism ===================================
IT means one thing aand many forms

four ways of implementing polymorphism:
1. Duck TYping
	x= 5  =>  x is just name to 5. WE got a space in m/m with a type int
	x= "rest"  =>  x is just name to "rest". WE got a space in m/m with a type string

	eg using class:

	
2. Operator Overloading
 	Whenever we are doing operation like +, -, / etc. Behind the scene we are calling a method
	respectively
	one operator with multiple form. When we like to do any operation on obj, we have to use magic methods
	 Operator will remain same, the operand will change. Ie. the type/number of parameter will be changed.
		eg a= 2, b=6  => a+b=> int().__add__(a, b)  # Type of parameter is int
		   a= "2", b= "6" => a+b=> str().__add__(a, b)  # Type of parameter is string
                   a= 2, b= 6, c= 1 => a+b=> int().__add__(a, b, c)   # The number of paramter is changed. But in all three operator is same.

	NOte: Make a note, only same type of parameter can be used. WE can not use string and int combined
  
	eg 
	a= 5, b= 6
	print(a+b) # SImillar to int().__add__(a, b)  -> This done behine the scene

	same is true if a nd b are string => str().__add__(a, b)

	And these __add__(), __sub__(), __mul__()  etc. are called magic methods.

	ie. All these operators behind the scene work as method

	Example using class:
  
  class student:
	
	def __init__(self, m1, m2):
	   self.m1= m1
	   self.m2= m2
	
	# THis is done to over load + operator, and we can use it, how like to use 
	# This will take 2 paramters self and other. They are variable name, we can change them
	
	# Example 1 operator overloading
	def __add__(self, other):
	    m1= self.m1+ other.m1
	    m2= self.m2+ other.m2
	    
	    m3= student(m1, m2)
	    return m3



  s1= student(80, 90)
  s2= student(75, 98)

  sum= s1+s2  => THis will throw error as unsupported operand type +. Because studnet class dont what is +. So use magic method
	to overload the operator like:  __add__()
  
    # After using __add__() method 
  sum= s1+s2  => become,  student.__add__(s1, s2)  # So, s1-> self, and s2-> other parameter
  
  print(sum) => wil be: <__main__.student object at 0x145ebc05cfd0>  => It will print address of sum object
		
  print(sum.m1)	=> It will print as 80+75=> 155

# == Example2 opperator overloading

  class student:
	
	def __init__(self, m1, m2):
	   self.m1= m1
	   self.m2= m2
	
	# Example 2 operator overloading. Lets add their own marks and compare
	def __gt__(self, other):
	    std1= self.m1 +self.m2
	    std2= other.m1 + other.m2
	    
	    if std1> std2:
		return True
	    else:
		return False


  s1= student(80, 90)
  s2= student(75, 98)

  if s1> s2:
	print("s1 wins")
  else:
	print("s2 wins")


# == Example 3  __str__()  => we can get value of object rather than address, In example1, when we print s3, we get address of an obj,
And if we dont want that, we can do operator overloading using __str__() magic method

class student:

  def __init__(self, m1, m2):
    self.m1= m1
    self.m2= m2

  def __add__(self, other):
    m1= self.m1+ other.m1
    m2= self.m2+ other.m2

    m3= student(m1, m2)
    return m3

  def __str__(self):
    return f"{self.m1}, {self.m2}"


s1= student(80, 90)
s2= student(75, 98)

s3= s1+s2

# Without __str__()  methiod
print(s1)            => o/p is address of an obj <__main__.student object at 0x14c2432a7130>
print(s2)            =>                          <__main__.student object at 0x147a82c6a0d0>
print(s3.m1, s3.m2)  => 155 188  due to __add__()

# With __str__()

print(s1)            => o/p is now value due to operator overloading of __str__(): 80, 90
print(s2)									 : 75, 98
print(s3.m1, s3.m2)  => 155 188  due to __add__()


3. Method Overloading

	THis concept in not in python. In same class if 2 or more Methods are having same name but take different number of parameters
can be called as method overloading.
	In python we cant create 2 methods in same class. So this concept nkt valid in python 

  #  SCenario 1 ===============

class student:

  def __init__(self, m1, m2):
    self.m1= m1
    self.m2= m2

  def find_sum(self, a, b):
    add= a + b
    print(add)

s1= student(80, 90)
s1.find_sum(2, 8)    => O/P is 10

 # == SCenario 2  ===============

WE create 2 methods with same name but diff parameters

class student:

  def __init__(self, m1, m2):
    self.m1= m1
    self.m2= m2

  def find_sum(self, a, b):
    add= a + b
    print(add)

  def find_sum(self, a, b, c):
    add= a + b + c
    print(add)
s1= student(80, 90)
s1.find_sum(2, 8, 1)  => O/P will be 11

# If we pass just arguments only. So, it will accept the highest arguments
s1.find_sum(2, 8)  => We get an errror:  TypeError: find_sum() missing 1 required positional argument: 'c'

# ======== Scenario 3 =======================
This is a way, we can do method overloading as directly making 2 methods with same name in same class does niot support in python

TO solve above issue, we can assign all expected number of parameters with None like below eg:

class student:

  def __init__(self, m1, m2):
    self.m1= m1
    self.m2= m2

  def find_sum(self, a= None, b=None, c=None):
    add= 0
    if a!= None and b!=None and c!=None:
      add= a + b + c
    elif a!= None and b!=None:
      add= a + b
    else:
      add= a
    print(add)
    
s1= student(80, 90)
s1.find_sum(2, 8, 1)
s1.find_sum(2, 8)
s1.find_sum(2)

4. Method overriding

	Two methods with same name and same number of parameters/arguments in diff classes.
eg

#  ========= scenario 1===================== 

Create 2 diff class. No common method with same name

class A:
  def show(self):
    print("CLass A")
    
class B:
   pass

obj= A()
obj.show()  => O/P is : CLass A

obj2= B()
obj2.show()  => AttributeError: 'B' object has no attribute 'show'

# =========== Scenario 2 =======================
Create 2 diff class where B is child of A. No common method with same name

class A:
  def show(self):
    print("CLass A")
    
class B(A):
   pass

obj= A()
obj.show()  => O/P is : CLass A

obj2= B()
obj2.show()  => O/P is : CLass A


# ============== SCenario 3 =========================

Create 2 diff class where B is child of A. Also in both having same method name.
So here Class B has all feature of A as its a child of A. BUt since its has same method which is available in parent class,
IT uses his own method. THis is called overriding

In short: It will first check method available in its own class, if not go for parent class

class A:
  def show(self):
    print("CLass A")
    
class B(A):
  def show(self):
    print("CLass B")

obj= A()
obj.show()  => O/P is : CLass A

obj2= B()
obj2.show()   => O/P is : CLass B
