# 3000
========= OOPS in python ==============

Python supports 
functional : The map(), filter() and reduce() functions bring a bit of functional programming to Python.
	All three of these are convenience functions that can be replaced with List Comprehensions or loops, but provide a more elegant and 		short-hand approach to some problems.

	# ==============  map()
	# Without using lambdas
	def starts_with_A(s):
    		return s[0] == "A"

	fruit = ["Apple", "Banana", "Pear", "Apricot", "Orange"]
	map_object = map(starts_with_A, fruit)

	print(list(map_object))  # [True, False, False, True, False]


	With lamda:
	
	fruit = ["Apple", "Banana", "Pear", "Apricot", "Orange"]
	map_object = map(lambda s: s[0] == "A", fruit)

	print(list(map_object))  # [True, False, False, True, False]

	

	# ============== filter()  # We can use lambda also similar to above
	The filter() function is used to generate an output list of values that return true
 when the function is called. It has the following syntax:

	def starts_with_A(s):
    		return s[0] == "A"

	fruit = ["Apple", "Banana", "Pear", "Apricot", "Orange"]
	filter_object = filter(starts_with_A, fruit)

	print(list(filter_object))  # ['Apple', 'Apricot']

	
	# ============== reduce()
	
	reduce() works differently than map() and filter(). It does not return a new list based on the function and iterable we've passed. 		Instead, it returns a single value.

	from functools import reduce

	def add(x, y):
    		return x + y

	list = [2, 4, 7, 3]
	print(reduce(add, list)) # 16  ie 2+4+6+3


Procedural
and OOP


class has
 attributes-> variables
 behaviour -> methods(function )


# ====================
Variable vs object

Object (a.k.a. value): a "thing". Lists, dictionaries, strings, numbers,
tuples, functions, and modules are all objects.
"Object" defies definition because everything is an object in Python.

Variable (a.k.a. name): a name used to refer to an object.

Pointer (a.k.a. reference): describes where an object lives (often shown visually as an arrow)

Equality: whether two objects represent the same data

Identity: whether two pointers refer to the same object


Equality compares objects and identity compares pointers.
Python's == operator checks that two objects represent the same data (a.k.a. equality):

>>> my_numbers = [2, 1, 3, 4]
>>> your_numbers = [2, 1, 3, 4]
>>> my_numbers == your_numbers
True

Python's is operator checks whether two objects are the same object (a.k.a. identity):

>>> my_numbers is your_numbers
False

If two variables point to the same object:

>>> my_numbers_again = my_numbers
>>> my_numbers is my_numbers_again
True

IN depth details:
eg a= 8 . Here a is name of object of object int. WE can check using print(type(a)) or isinstance(a, int)

lets say we have class name as computer. and we do comp= computer()
THan comp is an object of class computer. 



# ========= Memory management =========================

THere is special memory called as heap memory to store object in particular address.
FOr each object seperate address is allocated
we can get it by: print(id(object_name))

Memory management in Python involves a private heap containing all Python 
objects and data structures. The management of this private heap is ensured 
internally by the Python memory manager. The Python memory manager has 
different components which deal with various dynamic storage management aspects,
 like sharing, segmentation, preallocation or caching.

For example, integer objects are managed differently within the heap than strings,
 tuples or dictionaries because integers imply different storage requirements and speed/space tradeoffs. 

The management of the Python heap is performed by the interpreter
itself and that the user has no control over it




Size of an object-> depends on number of variables we have

who allocated size to object, how much m/m to be given-> THis is done by constructor. Or python memory manager
comp= Computer() -> This is constructor, which callls __init__() method called internally

# ====  self ====

self represent the instance(object) of the class.
self is the object we are passing. Useful in accessing data in diff methods

eg

class Computer():

   def __init__(self, ram):
      self.ram= ram  # => THis is like comp1.ram= ram

   def config(self):
      print("i5, 16gb ram")

comp1= Computer("i5")  # => Its like Computer(comp1, "i5")
comp2= Computer("i7")

Computer.config(comp1) # comp1 is passed as an argument

comp1.config()  # Behind the scenec comp1 is passeed as an argument


Its a current instance of object. With it helps only, we are displaying config method according to the object.

#  =======  __init__() ===============

Its a special method. This is used to initialize variables. Will be called automatically.
For every instance created, it be called.

Ii is constructor.

# =========  Variables in oops =====================


Useful to store data
1. Instance variables -> THey are diff for diff object. They are defined inside init method
2. class/static variables -> They are commmon for all. They are define outside init but inside class

# == Namespace =================
A namespace is a collection of currently defined symbolic names
along with information about the object that each name references.
You can think of a namespace as a dictionary in which the keys are the object names
and the values are the objects themselves. 
Each key-value pair maps a name to its corresponding object.

two types:
1, class namespace -> Where class variable are declared 
2. instance namespace-> PLcae where instance bvariables are declared

# ===========  Method TYpes ====================
Methos is used to define behaviour

1. class method-> It will have cls and thus deal with class variables. WE have to use decorator @classmethod to work it. eg. 			class_name.class_method()
2. instance method -> IT will have self and thus deal with instance variables. 
	Its of 2 types:
	1. Accesors-> When you just want to get/access the instance variables called accesors. They are also called getters
	2. Mutators-> When we modify/set instance variables called mutators. They are also called setters
3. static method-> When we like to do something which is not depending on class variables/instance variables, we can use it. This is not 		related to class/ object. WE have to use @staticmethod decorator.


eg:

from datetime import date

class Person:
	def __init__(self, name, age):
		self.name = name
		self.age = age

	@classmethod
	def fromBirthYear(cls, name, year):
		return cls(name, date.today().year - year)

	@staticmethod
	def isAdult(age):
		return age > 18

person1 = Person('mayank', 21)
person2 = Person.fromBirthYear('mayank', 1996)



print(person1.age)  	# 21
print(person2.age)	# 25

print(Person.isAdult(22))	# True


# ========== Inner class =================

Yes, we can do that.
eg
class Student:
  def __init__(self, name, roll):
	self.name= name
	self.roll= roll
	self.lap= self.laptop()  # Innecr class

  
  def show(self):
	print(self.name, self.roll)
	self.lap.show()  # Instance method of inner class

  class laptop:
	
	def __init__(self):
	   self.model= "hp"
	   self.cpu= "i5"
	   self.cost= 12000

	def show(self):  # Function name should be sam as above
	   print(self.model, self.cpu, self.cost)

s1= Student("Inder", 12)  # Inder 12

s1.show()  # hp i5 12000

# ============ Inheritance ==================
Mechanism in which child/sub class can have all properties of parent class.

Lets say we have 2 classes A and B. If B wanted to use all features of A. Than we can use inheritance.
Just have to use like: class B(A)

Example below is 
# single level inheritance. Where one child class inheriting 1 parent class.
parent(A)-> child(B) 
A is parent and B is child class

class A:
  def f1(self):
	print(f1)

class B(A):
  def f2(self):
	print(f2)

b1= B()
b1.      # It can access both f1 and f2

#  Multilevel inheritance
grandparent (A)-> parent(B)-> child(C)

C is having all features available from both A and class B. B is having all features from A also
class A:
  def f1(self):
	print(f1)

class B(A):
  def f2(self):
	print(f2)

class C(B):
  def f3(self):
	print(f3)

c1= C()
c1.  # It can access all f1, f2 and f3


# == Multiple Inheritance ====
parent (A)
	   -> child(C)
parent(B)   

C is inheriting features from one or more classes. Here B is having only f2 feature and A is having f1 feature

class A:
  def f1(self):
	print(f1)

class B:
  def f2(self):
	print(f2)

class C(A, B):
  def f3(self):
	print(f3)

c1= C()
c1.  # It can access all f1, f2 and f3




# ============  Constructor in inheritances ===============================

# ======== 1. HOw constructor behave in inheritance

class A:
  def __init__(self):
	print("init of A")
  def f1(self):
	print(f1)

class B(A):
  def __init__(self):
	print("init of B")
  def f2(self):
	print(f2)

b1= B() => It will inherit all features of class A. 
	It will first check, if init is present in class B(sub class) and display
	 if init not found in CLASS B, than check init in CLASS A(super class) and print init method.

ie. if you create object of subclass it will first try to find init of subclass,
If not found than only it will call init of super class


# ======== 2. HOw to use super() method ============

What if I like to call init of A also?
than use : super().__init__()  inside __init__() of class B
like:
class B(A):
  def __init__(self):
	super().__init__()
	print("init of B")

with super(). -> WE can access any method of super class. init as well other method of super class


Above is true for single level/ multi level inheritence. Ie where a child is inheriting a single parent.

But in case of multiple inheritence, where a child inherit multiple parents, 

like:
class A:
  def __init__(self):
	print("init of A")
  def f1(self):
	print(f1)

class B:
  def __init__(self):
	print("init of B")
  def f2(self):
	print(f2)

class C(A,B):
  def __init__(self):
	super().__init__()
	print("init of C")
  def f3(self):
	print(f3)

c1= C() => It will print init of A and init C only. And init of B will not be called. Here C(A, B) -> A is at first that is why.
It follows, first check for init in C than go to left CLASS Ie A to find init than comes right  CLASS ie B to find init.

above concept to get init method of parent class, fails. As, now sub class will have 2 super class.
 But super(). function used to call just one super class, and it gets confused.

# =============== 3. Method Resolution Order(MRO) ================================

To overcome above issue, MRO is used.

like:
class A:
  def __init__(self):
	print("init of A")
  def f1(self):
	print(f1 of class A)

class B:
  def __init__(self):
	print("init of B")
  def f1(self):
	print(f1 of class b)

class C(A,B):
  def __init__(self):
	super().__init__()
	print("init of C")
  def f2(self):
	print(f2)

c1= C() => # Constructor of A will be called and not constructor B as A in left. ==> init of A and init of C will be printed

c1.f1()   # f1 is common in A and B, f1 of A will be called as A is in left     => f1 of class A will be printed


# ===============  Polymorphism ===================================
IT means one thing aand many forms

four ways of implementing polymorphism:
1. Duck TYping
	x= 5  =>  x is just name to 5. WE got a space in m/m with a type int
	x= "rest"  =>  x is just name to "rest". WE got a space in m/m with a type string

	eg using class:

	
2. Operator Overloading
 	Whenever we are doing operation like +, -, / etc. Behind the scene we are calling a method
	respectively
	one operator with multiple form. When we like to do any operation on obj, we have to use magic methods
	 Operator will remain same, the operand will change. Ie. the type/number of parameter will be changed.
		eg a= 2, b=6  => a+b=> int().__add__(a, b)  # Type of parameter is int
		   a= "2", b= "6" => a+b=> str().__add__(a, b)  # Type of parameter is string
                   a= 2, b= 6, c= 1 => a+b=> int().__add__(a, b, c)   # The number of paramter is changed. But in all three operator is same.

	NOte: Make a note, only same type of parameter can be used. WE can not use string and int combined
  
	eg 
	a= 5, b= 6
	print(a+b) # SImillar to int().__add__(a, b)  -> This done behine the scene

	same is true if a nd b are string => str().__add__(a, b)

	And these __add__(), __sub__(), __mul__()  etc. are called magic methods.

	ie. All these operators behind the scene work as method

	Example using class:
  
  class student:
	
	def __init__(self, m1, m2):
	   self.m1= m1
	   self.m2= m2
	
	# THis is done to over load + operator, and we can use it, how like to use 
	# This will take 2 paramters self and other. They are variable name, we can change them
	
	# Example 1 operator overloading
	def __add__(self, other):
	    m1= self.m1+ other.m1
	    m2= self.m2+ other.m2
	    
	    m3= student(m1, m2)
	    return m3



  s1= student(80, 90)
  s2= student(75, 98)

  sum= s1+s2  => THis will throw error as unsupported operand type +. Because studnet class dont what is +. So use magic method
	to overload the operator like:  __add__()
  
    # After using __add__() method 
  sum= s1+s2  => become,  student.__add__(s1, s2)  # So, s1-> self, and s2-> other parameter
  
  print(sum) => wil be: <__main__.student object at 0x145ebc05cfd0>  => It will print address of sum object
		
  print(sum.m1)	=> It will print as 80+75=> 155

# == Example2 opperator overloading

  class student:
	
	def __init__(self, m1, m2):
	   self.m1= m1
	   self.m2= m2
	
	# Example 2 operator overloading. Lets add their own marks and compare
	def __gt__(self, other):
	    std1= self.m1 +self.m2
	    std2= other.m1 + other.m2
	    
	    if std1> std2:
		return True
	    else:
		return False


  s1= student(80, 90)
  s2= student(75, 98)

  if s1> s2:
	print("s1 wins")
  else:
	print("s2 wins")


# == Example 3  __str__()  => we can get value of object rather than address, In example1, when we print s3, we get address of an obj,
And if we dont want that, we can do operator overloading using __str__() magic method

class student:

  def __init__(self, m1, m2):
    self.m1= m1
    self.m2= m2

  def __add__(self, other):
    m1= self.m1+ other.m1
    m2= self.m2+ other.m2

    m3= student(m1, m2)
    return m3

  def __str__(self):
    return f"{self.m1}, {self.m2}"


s1= student(80, 90)
s2= student(75, 98)

s3= s1+s2

# Without __str__()  methiod
print(s1)            => o/p is address of an obj <__main__.student object at 0x14c2432a7130>
print(s2)            =>                          <__main__.student object at 0x147a82c6a0d0>
print(s3.m1, s3.m2)  => 155 188  due to __add__()

# With __str__()

print(s1)            => o/p is now value due to operator overloading of __str__(): 80, 90
print(s2)									 : 75, 98
print(s3.m1, s3.m2)  => 155 188  due to __add__()


3. Method Overloading

	THis concept in not in python. In same class if 2 or more Methods are having same name but take different number of parameters
can be called as method overloading.
	In python we cant create 2 methods in same class. So this concept nkt valid in python 

  #  SCenario 1 ===============

class student:

  def __init__(self, m1, m2):
    self.m1= m1
    self.m2= m2

  def find_sum(self, a, b):
    add= a + b
    print(add)

s1= student(80, 90)
s1.find_sum(2, 8)    => O/P is 10

 # == SCenario 2  ===============

WE create 2 methods with same name but diff parameters

class student:

  def __init__(self, m1, m2):
    self.m1= m1
    self.m2= m2

  def find_sum(self, a, b):
    add= a + b
    print(add)

  def find_sum(self, a, b, c):
    add= a + b + c
    print(add)
s1= student(80, 90)
s1.find_sum(2, 8, 1)  => O/P will be 11

# If we pass just arguments only. So, it will accept the highest arguments
s1.find_sum(2, 8)  => We get an errror:  TypeError: find_sum() missing 1 required positional argument: 'c'

# ======== Scenario 3 =======================
This is a way, we can do method overloading as directly making 2 methods with same name in same class does niot support in python

TO solve above issue, we can assign all expected number of parameters with None like below eg:

class student:

  def __init__(self, m1, m2):
    self.m1= m1
    self.m2= m2

  def find_sum(self, a= None, b=None, c=None):
    add= 0
    if a!= None and b!=None and c!=None:
      add= a + b + c
    elif a!= None and b!=None:
      add= a + b
    else:
      add= a
    print(add)
    
s1= student(80, 90)
s1.find_sum(2, 8, 1)
s1.find_sum(2, 8)
s1.find_sum(2)

4. Method overriding

	Two methods with same name and same number of parameters/arguments in diff classes.
eg

#  ========= scenario 1===================== 

Create 2 diff class. No common method with same name

class A:
  def show(self):
    print("CLass A")
    
class B:
   pass

obj= A()
obj.show()  => O/P is : CLass A

obj2= B()
obj2.show()  => AttributeError: 'B' object has no attribute 'show'

# =========== Scenario 2 =======================
Create 2 diff class where B is child of A. No common method with same name

class A:
  def show(self):
    print("CLass A")
    
class B(A):
   pass

obj= A()
obj.show()  => O/P is : CLass A

obj2= B()
obj2.show()  => O/P is : CLass A


# ============== SCenario 3 =========================

Create 2 diff class where B is child of A. Also in both having same method name.
So here Class B has all feature of A as its a child of A. BUt since its has same method which is available in parent class,
IT uses his own method. THis is called overriding

In short: It will first check method available in its own class, if not go for parent class

class A:
  def show(self):
    print("CLass A")
    
class B(A):
  def show(self):
    print("CLass B")

obj= A()
obj.show()  => O/P is : CLass A

obj2= B()
obj2.show()   => O/P is : CLass B


# ==========  Abstract class ==============



An abstract class can be considered as a blueprint for other classes.
It allows you to create a set of methods that must be created within any child classes built from the abstract class.
 A class which contains one or more abstract methods is called an abstract class.
 An abstract method is a method that has a declaration but does not have an implementation. 


eg:

# Python program showing
# abstract base class work

from abc import ABC, abstractmethod

class sides(ABC):

	@abstractmethod
	def my_sides(self):
		pass

class Triangle(sides):

	# overriding abstract method
	def my_sides(self):
		print("I have 3 sides")

class Pentagon(sides):

	# overriding abstract method
	def my_sides(self):
		print("I have 5 sides")

class Hexagon(sides):

	# overriding abstract method
	def my_sides(self):
		print("I have 6 sides")

class Quadrilateral(sides):

	# overriding abstract method
	def my_sides(self):
		print("I have 4 sides")

# Driver code
R = Triangle()
R.my_sides()

K = Quadrilateral()
K.my_sides()

R = Pentagon()
R.my_sides()

K = Hexagon()
K.my_sides()

# =================================================










# FAQ ===================

Q1. What are the different types of datatypes in python?
	list, tuple, string, set, dictionary

Q2. How do you concatenate a string and integer? is it possible ?
	YEs, 
	x= "qwerty"
	y= 6
	add= x+ str(y)

Q3. What is xpath ? How do you find an element ? what is the difference between absolute xpath and relative xpath?
	can be used to navigate through elements and attributes in an XML document.

Q4. What are different locators supported in selenium?
	ID, NAME, XPATH, CSS_SELECTOR, CLASS, LINK_TEXT

Q5. What is the difference between findelement and findelements?
	find_element-> locate just one elemenet
	find_element-> locate multiple elements and stored them in list

Q6. What are the exceptions in selenium?
	Timeout, nosuchelemet, elementnot interactable

Q7. How do you select a value from dropdown in selenium?
	using select

Q8. How do you achieve synchronization? what are the differences between the synchronization ways?
	wait

Q9. What is the difference between break continue and pass?


Q10. What is full join ?
	Under SQL joins, Full Join is a keyword, which is used to select 
	all records from the right table and also from the left table

Q11. Write a Query to Find Second Highest Salary in SQL
	The MIN() function returns the smallest value of the selected column.
	The MAX() function returns the largest value of the selected column.

	SELECT MAX(Price) AS SmallestPrice
	FROM Products
	WHERE Price < (SELECT MAX(Price) AS SmallestPrice
	FROM Products);

Q12. How to fetch 1st 5 records in sql?
	SELECT TOP 5 * FROM Products;
	or
	SELECT * FROM Customers LIMIT 5;

Q13. How do you copy a table in mysql?
	SELECT * INTO new_table
	FROM old_table;  # IN same db

	SELECT * INTO new_table IN 'Backup.mdb'
	FROM old_table;   # In another db

Q14. How do you fetch unique elements from a column?
	SELECT DISTINCT(Country) FROM Customers ;

Q15. Write an SQL query to find names of employees start with ‘A’?
	SELECT * FROM Customers
	WHERE CustomerName LIKE "A%";

Q16. How do you open a file and read repeating words from a file ?
	with open("/home/inder/my_data/educational_content/python_projects/interview_programs/all_questions/python/file_operation/read_file_input.txt", "r") as file:

    content= file.read()

print(content)

list1= content.split()
dict1= {}
print(list1)
for item in list1:

    if item in dict1.keys():
        dict1[item]= dict1[item]+ 1
    
    else:
        dict1[item]= 1

for key, value in dict1.items():
    if value > 1:
        print(f"{key}-> {value}")
	
Q17. How do you generate random emails in python? gmail.com is constant
	import random


MAX_LEN = 12

DIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
LOCASE_CHARACTERS = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',
                     'i', 'j', 'k', 'm', 'n', 'o', 'p', 'q',
                     'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
                     'z']

UPCASE_CHARACTERS = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
                     'I', 'J', 'K', 'M', 'N', 'O', 'P', 'Q',
                     'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
                     'Z']

SYMBOLS = ['@', '#', '$', '%', '=', ':', '?', '.', '/', '|', '~', '>',
           '*', '(', ')', '<']

COMBINED_LIST = DIGITS + UPCASE_CHARACTERS + LOCASE_CHARACTERS + SYMBOLS

# Select atlest once each

rand_digit= random.choice(DIGITS)
rand_upper = random.choice(UPCASE_CHARACTERS)
rand_lower = random.choice(LOCASE_CHARACTERS)
rand_symbol = random.choice(SYMBOLS)

temp_pass =  rand_upper + rand_lower + rand_digit + rand_symbol

# Our target is to make mixed string of 12 char. and from temp_pass only 4 is done. So remaing 8 char we can take from combined

for i  in range(8):

    temp_pass= temp_pass+ random.choice(COMBINED_LIST)

print(temp_pass)

remaining_gmail= "@gmail.com"

overall= temp_p

Q18. How do you generate random data / number in python ?
	same as above, random.choice(list1)

Q19. What is the difference between array and a list ?
Add Answer
Q20. How do you run a test suite using robotframework command line ?
Add Answer
Q21. If some data is not found on the page, do page refresh and how do you validate a data after page refresh in selenium?
